import * as vscode from 'vscode';
import OpenAI from 'openai';
import * as dotenv from 'dotenv';
import { getWebviewContent } from './getWebviewContent';
import * as fs from 'fs';
import * as path from 'path';


// Load environment variables from .env file
// require('dotenv').config({path:__dirname+'/./../.env'});
// dotenv.config();

// Function to load the content of a file
function loadPromptContent(filename: string): string {
    const filePath = path.join(__dirname, 'prompts/prod/', filename);
    console.log(`Loading prompt from: ${filePath}`); // Debug log to check file path
    if (!fs.existsSync(filePath)) {
        console.error(`File not found: ${filePath}`);
        return '';
    }
    return fs.readFileSync(filePath, 'utf-8');
}

export function activate(context: vscode.ExtensionContext) {
    let responseText: string | null = null;

    // get configuation settings
    const configs = vscode.workspace.getConfiguration('reportAssistant');
    const apiKey = configs.get<string>('apiKey');

    if (!apiKey) {
        throw new Error('The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: "My API Key" }).');
        return;
    }

    //openai session
    const openai = new OpenAI({
        apiKey: apiKey,
    });

    const hoverProvider = vscode.languages.registerHoverProvider('*', {
        async provideHover(document, position, token) {
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                return;
            }

            const selection = editor.selection;
            let hoveredText: string;

            if (!selection.isEmpty) {
                // Use the selected text
                hoveredText = document.getText(selection);
            } else {
                // Fallback to the word at the position
                const range = document.getWordRangeAtPosition(position, /[^\s]+.*/);
                if (!range) {
                    return;
                }
                hoveredText = document.getText(range);
            }

            const sys_prompt = loadPromptContent('sys_prompt1.txt');
            console.log(sys_prompt);
            const prompt = loadPromptContent('prompt1.txt')+`\n${hoveredText}\n`+"The output must be only a revised passage from you";
            console.log(prompt);

            try {
                const response = await callChatGPT(openai, prompt, sys_prompt);
                if (response) {
                    responseText = response;
                    const markdownString = new vscode.MarkdownString();
                    markdownString.appendMarkdown(`**Report Assistant**\n\n`);
                    markdownString.appendMarkdown(`***\n\n`);
                    markdownString.appendText(response);
                    markdownString.appendMarkdown(`\n\n***`);
                    markdownString.appendMarkdown(`\n\n[Apply Changes](command:extension.applyChanges)`);
                    markdownString.isTrusted = true;
                    return new vscode.Hover(markdownString);
                } else {
                    vscode.window.showErrorMessage('No response from ChatGPT API');
                }
            } catch (error) {
                vscode.window.showErrorMessage(`Error calling ChatGPT API:`, (error as Error).message);
            }
        }
    });

    context.subscriptions.push(hoverProvider);

    const applyChangesCommand = vscode.commands.registerCommand('extension.applyChanges', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            return;
        }

        const selection = editor.selection;
        if (!selection.isEmpty && responseText) {
            await editor.edit(editBuilder => {
                editBuilder.replace(selection, responseText as string);
            });
        } else {
            vscode.window.showErrorMessage('No text selected or no response from ChatGPT API');
        }
    });

    context.subscriptions.push(applyChangesCommand);

    // Insert "Hello, this is from extension"
    const insertHelloCommand = vscode.commands.registerCommand('extension.insertHello', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found.');
            return;
        }
        const position = editor.selection.active;
        try {
            const success = await editor.edit(editBuilder => {
                editBuilder.insert(position, "Hello, this is from extension");
            });

            if (success) {
                vscode.window.showInformationMessage('Inserted "Hello, this is from extension"');
            } else {
                vscode.window.showErrorMessage('Failed to insert text.');
            }
        } catch (error) {
            vscode.window.showErrorMessage(`Insert command failed: ${(error as Error).message}`);
        }
    });

    context.subscriptions.push(insertHelloCommand);

    // Command to generate Web Application Suggestion
    const genWebAppSuggestion = vscode.commands.registerCommand('extension.genWebAppSuggestion', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found.');
            return;
        }

        const document = editor.document;
        const fileName = document.fileName.split('/').pop(); // Extract the file name from the path
        const fileNameParts = fileName ? fileName.split(' ~ ') : [];
        console.log(fileNameParts);

        const content = document.getText();
        // Extract the Testing Process section
        const testingProcessMatch = content.match(/## Testing Process\s*([\s\S]*)/);
        if (!testingProcessMatch) {
            vscode.window.showErrorMessage('No Testing Process section found.');
            return;
        }

        const testingProcess = testingProcessMatch[1].trim();

        // Exclude lines containing the pattern `![](...)`
        const filteredTestingProcess = testingProcess
            .split('\n')
            .filter(line => !line.match(/!\[\]\(.*?\)/))
            .join('\n');
        const cleanTestingProcess = filteredTestingProcess.replace(/\n+/g, '\n');

        const sys_prompt = loadPromptContent('sys_prompt2.txt');
        console.log(sys_prompt);
        //debugging
        const prompt = loadPromptContent('web.txt')+`\nTesting Process:\n${cleanTestingProcess}`;
        console.log(prompt);

        try {
            const response = await callChatGPT(openai, prompt, sys_prompt);
            if (response) {
                const responseJson = JSON.parse(response);
                const suggestedFileName = fileNameParts[1];
                const panel = vscode.window.createWebviewPanel(
                    'reportAssistant',
                    'Report Assistant',
                    vscode.ViewColumn.Beside, // Open in split view
                    {
                        enableScripts: true
                    }
                );
                const issue1 = responseJson["issue1"];
                const issue2 = responseJson["issue2"];
                const issue3 = responseJson["issue3"];

                panel.webview.html = getWebviewContent(issue1, issue2, issue3, suggestedFileName);
            } else {
                vscode.window.showErrorMessage('No response from ChatGPT API');
            }
        } catch (error) {
            if (error instanceof SyntaxError) {
                vscode.window.showErrorMessage('Failed to parse response from ChatGPT API. Ensure the response is in JSON format.');
            } else {
                vscode.window.showErrorMessage(`Error calling ChatGPT API: ${(error as Error).message}`);
            }
        }
    });

    context.subscriptions.push(genWebAppSuggestion);

    // Command to generate Mobile Application Suggestion
    const genMobileAppSuggestion = vscode.commands.registerCommand('extension.genMobileAppSuggestion', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found.');
            return;
        }

        const document = editor.document;
        const fileName = document.fileName.split('/').pop(); // Extract the file name from the path
        const fileNameParts = fileName ? fileName.split(' ~ ') : [];
        console.log(fileNameParts);

        const content = document.getText();
        // Extract the Testing Process section
        const testingProcessMatch = content.match(/## Testing Process\s*([\s\S]*)/);
        if (!testingProcessMatch) {
            vscode.window.showErrorMessage('No Testing Process section found.');
            return;
        }

        const testingProcess = testingProcessMatch[1].trim();

        // Exclude lines containing the pattern `![](...)`
        const filteredTestingProcess = testingProcess
            .split('\n')
            .filter(line => !line.match(/!\[\]\(.*?\)/))
            .join('\n');
        const cleanTestingProcess = filteredTestingProcess.replace(/\n+/g, '\n');

        const sys_prompt = loadPromptContent('sys_prompt2.txt');
        console.log(sys_prompt);
        //debugging
        const prompt = loadPromptContent('mobile.txt')+`\nTesting Process:\n${cleanTestingProcess}`;
        console.log(prompt);

        try {
            const response = await callChatGPT(openai, prompt, sys_prompt);
            if (response) {
                const responseJson = JSON.parse(response);
                const suggestedFileName = fileNameParts[1];
                const panel = vscode.window.createWebviewPanel(
                    'reportAssistant',
                    'Report Assistant',
                    vscode.ViewColumn.Beside, // Open in split view
                    {
                        enableScripts: true
                    }
                );
                const issue1 = responseJson["issue1"];
                const issue2 = responseJson["issue2"];
                const issue3 = responseJson["issue3"];

                panel.webview.html = getWebviewContent(issue1, issue2, issue3, suggestedFileName);
            } else {
                vscode.window.showErrorMessage('No response from ChatGPT API');
            }
        } catch (error) {
            if (error instanceof SyntaxError) {
                vscode.window.showErrorMessage('Failed to parse response from ChatGPT API. Ensure the response is in JSON format.');
            } else {
                vscode.window.showErrorMessage(`Error calling ChatGPT API: ${(error as Error).message}`);
            }
        }
    });

    context.subscriptions.push(genMobileAppSuggestion);
}

async function callChatGPT(openai: OpenAI, prompt: string, sys_prompt: string): Promise<string | null> {
    try {
        const completion = await openai.chat.completions.create({
            //model: "gpt-3.5-turbo-0125",
            model: "gpt-4o",
            messages: [
                { role: "system", content: sys_prompt },
                { role: "user", content: prompt }
            ],
            response_format: { type: "json_object" },
        });
        console.log("Total tokens:", completion.usage?.total_tokens);
        console.log("Prompt tokens:", completion.usage?.prompt_tokens);
        console.log("Completion tokens:", completion.usage?.completion_tokens);

        const messageContent = completion.choices[0]?.message?.content;
        console.log("Message Content:\n", messageContent);

        if (messageContent) {
            return messageContent;
        } else {
            console.error('No message content in the completion response');
            return null;
        }
    } catch (error) {
        console.error(error);
        throw new Error(`Error calling ChatGPT API:`, (error as Error));
    }
}

export function deactivate() { }
