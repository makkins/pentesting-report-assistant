import * as vscode from 'vscode';
import OpenAI from 'openai';
import * as dotenv from 'dotenv';
import { getWebviewContent } from './getWebviewContent';
import { getAppviewContent } from './getAppviewContent';
import * as fs from 'fs';
import * as path from 'path';
import { calculatorViewContent } from './calculatorViewContent';


// Load environment variables from .env file
// require('dotenv').config({path:__dirname+'/./../.env'});
// dotenv.config();

// Function to load the content of a file

export function activate(context: vscode.ExtensionContext) {
    let responseText: string | null = null;

    // get configuation settings
    const configs = vscode.workspace.getConfiguration('reportAssistant');
    const apiKey = configs.get<string>('apiKey');

    if (!apiKey) {
        throw new Error('The OPENAI_API_KEY environment variable is missing or empty; either provide it, or instantiate the OpenAI client with an apiKey option, like new OpenAI({ apiKey: "My API Key" }).');
        return;
    }

    //openai session
    const openai = new OpenAI({
        apiKey: apiKey,
    });

    const hoverProvider = vscode.languages.registerHoverProvider('*', {
        async provideHover(document, position, token) {
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                return;
            }

            const selection = editor.selection;
            let hoveredText: string;

            if (!selection.isEmpty) {
                // Use the selected text
                hoveredText = document.getText(selection);
            } else {
                // Fallback to the word at the position
                const range = document.getWordRangeAtPosition(position, /[^\s]+.*/);
                if (!range) {
                    return;
                }
                hoveredText = document.getText(range);
            }

            const sys_prompt = loadPromptContent('sys_corr.txt');
            console.log(sys_prompt);
            const prompt = loadPromptContent('correction.txt') + `\n${hoveredText}\n` + "The output must be only a revised passage from you";
            console.log(prompt);

            try {
                const response = await callChatGPT(openai, prompt, sys_prompt);
                if (response) {
                    responseText = response;
                    const markdownString = new vscode.MarkdownString();
                    markdownString.appendMarkdown(`**Report Assistant**\n\n`);
                    markdownString.appendMarkdown(`***\n\n`);
                    markdownString.appendText(response);
                    markdownString.appendMarkdown(`\n\n***`);
                    markdownString.appendMarkdown(`\n\n[Apply Changes](command:extension.applyChanges)`);
                    markdownString.isTrusted = true;
                    return new vscode.Hover(markdownString);
                } else {
                    vscode.window.showErrorMessage('No response from ChatGPT API');
                }
            } catch (error) {
                vscode.window.showErrorMessage(`Error calling ChatGPT API:`, (error as Error).message);
            }
        }
    });

    context.subscriptions.push(hoverProvider);

    const applyChangesCommand = vscode.commands.registerCommand('extension.applyChanges', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            return;
        }

        const selection = editor.selection;
        if (!selection.isEmpty && responseText) {
            await editor.edit(editBuilder => {
                editBuilder.replace(selection, responseText as string);
            });
        } else {
            vscode.window.showErrorMessage('No text selected or no response from ChatGPT API');
        }
    });

    context.subscriptions.push(applyChangesCommand);

    // # TEST FUNCTION
    // // Insert "Hello, this is from extension"
    // const insertHelloCommand = vscode.commands.registerCommand('extension.insertHello', async () => {
    //     const editor = vscode.window.activeTextEditor;
    //     if (!editor) {
    //         vscode.window.showErrorMessage('No active editor found.');
    //         return;
    //     }
    //     const position = editor.selection.active;
    //     try {
    //         const success = await editor.edit(editBuilder => {
    //             editBuilder.insert(position, "Hello, this is from extension");
    //         });

    //         if (success) {
    //             vscode.window.showInformationMessage('Inserted "Hello, this is from extension"');
    //         } else {
    //             vscode.window.showErrorMessage('Failed to insert text.');
    //         }
    //     } catch (error) {
    //         vscode.window.showErrorMessage(`Insert command failed: ${(error as Error).message}`);
    //     }
    // });

    // context.subscriptions.push(insertHelloCommand);
    //

    // Command to generate Web Application Suggestion
    const genWebAppSuggestion = vscode.commands.registerCommand('extension.genWebAppSuggestion', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found.');
            return;
        }
        // Process Tracker
        let statusBarMessage: vscode.Disposable | undefined = undefined;
        vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Generating Web Apps Suggestion",
            cancellable: false
        }, async (progress) => {
            progress.report({ increment: 0, message: "Preparing..." });
            await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate preparation time

            const document = editor.document;
            const fileName = document.fileName.split('/').pop(); // Extract the file name from the path
            const fileNameParts = fileName ? fileName.split(' ~ ') : [];
            console.log(fileNameParts);

            const content = document.getText();
            // Extract the Testing Process section
            const testingProcessMatch = content.match(/## Testing Process\s*([\s\S]*)/);
            if (!testingProcessMatch) {
                vscode.window.showErrorMessage('No Testing Process section found.');
                return;
            }

            const testingProcess = testingProcessMatch[1].trim();

            // Exclude lines containing the pattern `![](...)`
            const filteredTestingProcess = testingProcess
                .split('\n')
                .filter(line => !line.match(/!\[\]\(.*?\)/))
                .join('\n');
            const cleanTestingProcess = filteredTestingProcess.replace(/\n+/g, '\n');

            const sys_prompt = loadPromptContent('sys_sugg.txt');
            console.log(sys_prompt);
            //debugging
            const prompt = loadPromptContent('web.txt') + `\nTesting Process:\n${cleanTestingProcess}`;
            console.log(prompt);
            progress.report({ increment: 40, message: "Calling ChatGPT..." });


            try {
                statusBarMessage = showStatusMessage('Generating Suggestion...');
                const response = await callChatGPTJson(openai, prompt, sys_prompt);
                progress.report({ increment: 70, message: "Processing response..." });
                if (response) {
                    const responseJson = JSON.parse(response);
                    const suggestedFileName = fileNameParts[1];
                    const panel = vscode.window.createWebviewPanel(
                        'reportAssistant',
                        'Report Assistant',
                        vscode.ViewColumn.Beside, // Open in split view
                        {
                            enableScripts: true
                        }
                    );
                    const issue1 = responseJson["issue1"];
                    const issue2 = responseJson["issue2"];
                    const issue3 = responseJson["issue3"];

                    panel.webview.html = getAppviewContent(issue1, issue2, issue3, suggestedFileName);
                    progress.report({ increment: 100, message: "Completed" });
                    vscode.window.showInformationMessage('Web Apps Suggestion Generated Successfully.');
                } else {
                    vscode.window.showErrorMessage('No response from ChatGPT API');
                }
            } catch (error) {
                if (error instanceof SyntaxError) {
                    vscode.window.showErrorMessage('Failed to parse response from ChatGPT API. Ensure the response is in JSON format.');
                } else {
                    vscode.window.showErrorMessage(`Error calling ChatGPT API: ${(error as Error).message}`);
                }
            } finally {
                if (statusBarMessage) {
                    statusBarMessage.dispose();
                }
            }
        });
    });

    context.subscriptions.push(genWebAppSuggestion);

    // Command to generate Mobile Application Suggestion
    const genMobileAppSuggestion = vscode.commands.registerCommand('extension.genMobileAppSuggestion', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found.');
            return;
        }

        // Process Tracker
        let statusBarMessage: vscode.Disposable | undefined = undefined;
        vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: "Generating Mobile Apps Suggestion",
            cancellable: false
        }, async (progress) => {
            progress.report({ increment: 0, message: "Preparing..." });
            await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate preparation time

            const document = editor.document;
            const fileName = document.fileName.split('/').pop(); // Extract the file name from the path
            const fileNameParts = fileName ? fileName.split(' ~ ') : [];
            console.log(fileNameParts);

            const content = document.getText();
            // Extract the Testing Process section
            const testingProcessMatch = content.match(/## Testing Process\s*([\s\S]*)/);
            if (!testingProcessMatch) {
                vscode.window.showErrorMessage('No Testing Process section found.');
                return;
            }

            const testingProcess = testingProcessMatch[1].trim();

            // Exclude lines containing the pattern `![](...)`
            const filteredTestingProcess = testingProcess
                .split('\n')
                .filter(line => !line.match(/!\[\]\(.*?\)/))
                .join('\n');
            const cleanTestingProcess = filteredTestingProcess.replace(/\n+/g, '\n');

            // Loading CMD prompts
            const sys_prompt = loadPromptContent('sys_sugg.txt');
            console.log(sys_prompt);

            const prompt = loadPromptContent('mobile.txt') + `\nTesting Process:\n${cleanTestingProcess}`;
            console.log(prompt);
            progress.report({ increment: 40, message: "Calling API..." });

            try {
                statusBarMessage = showStatusMessage('Generating Suggestion...');
                const response = await callChatGPTJson(openai, prompt, sys_prompt);
                progress.report({ increment: 70, message: "Processing response..." });
                if (response) {
                    const responseJson = JSON.parse(response);
                    const suggestedFileName = fileNameParts[1];
                    const panel = vscode.window.createWebviewPanel(
                        'reportAssistant',
                        'Report Assistant',
                        vscode.ViewColumn.Beside, // Open in split view
                        {
                            enableScripts: true
                        }
                    );
                    const issue1 = responseJson["issue1"];
                    const issue2 = responseJson["issue2"];
                    const issue3 = responseJson["issue3"];

                    panel.webview.html = getAppviewContent(issue1, issue2, issue3, suggestedFileName);
                    progress.report({ increment: 100, message: "Completed" });
                    vscode.window.showInformationMessage('Mobile Apps Suggestion Generated Successfully.');
                } else {
                    vscode.window.showErrorMessage('No response from ChatGPT API');
                }
            } catch (error) {
                if (error instanceof SyntaxError) {
                    vscode.window.showErrorMessage('Failed to parse response from ChatGPT API. Ensure the response is in JSON format.');
                } else {
                    vscode.window.showErrorMessage(`Error calling ChatGPT API: ${(error as Error).message}`);
                }
            } finally {
                if (statusBarMessage) {
                    statusBarMessage.dispose();
                }
            }
        });
    });

    context.subscriptions.push(genMobileAppSuggestion);

    // Register the risk calculator command
    let panel: vscode.WebviewPanel | undefined = undefined;
    const openRiskCalculatorCommand = vscode.commands.registerCommand('extension.openRiskCalculator', async (uri: vscode.Uri) => {
        if (panel) {
            // If the panel is already created, just reveal it
            panel.reveal(vscode.ViewColumn.One);
        } else {
            // Otherwise, create a new panel
            panel = vscode.window.createWebviewPanel(
                'riskCalculator', // Identifies the type of the webview. Used internally
                'Risk Calculator', // Title of the panel displayed to the user
                vscode.ViewColumn.Beside, // Editor column to show the new webview panel in.
                {
                    enableScripts: true // Enable scripts in the webview
                }
            );

            // Set the HTML content for the webview
            panel.webview.html = calculatorViewContent();

            // Handle messages from the webview
            panel.webview.onDidReceiveMessage(
                async message => {
                    switch (message.command) {
                        case 'calculateRisk':
                            const results = calculateRisk(message.data);
                            await updateTextFile(uri, results);
                            const newUri = await renameFile(uri, results);
                            if (panel) {
                                panel.webview.postMessage({ command: 'showResults', ...results });
                            }
                            if (newUri) {
                                // Update the URI to the new file location if renamed
                                uri = newUri;
                            }
                            return;
                    }
                },
                undefined,
                context.subscriptions
            );

            // Handle panel disposal
            panel.onDidDispose(() => {
                panel = undefined;
            }, null, context.subscriptions);
        }
    });

    context.subscriptions.push(openRiskCalculatorCommand);
}

// change file name
async function updateTextFile(uri: vscode.Uri, results: any) {
    const document = await vscode.workspace.openTextDocument(uri);
    const text = document.getText();
    const updatedText = text.replace(/\[Impact\]\s+:\s+\w+/, `[Impact] : ${results.impact.level}`)
        .replace(/\[Likelihood\]\s+:\s+\w+/, `[Likelihood] : ${results.likelihood.level}`);

    const edit = new vscode.WorkspaceEdit();
    edit.replace(uri, new vscode.Range(0, 0, document.lineCount, 0), updatedText);
    await vscode.workspace.applyEdit(edit);
    await document.save();
}

async function renameFile(uri: vscode.Uri, results: any): Promise<vscode.Uri | undefined> {
    const oldPath = uri.fsPath;
    const dir = path.dirname(oldPath);
    const ext = path.extname(oldPath);
    const baseName = path.basename(oldPath, ext);
    const parts = baseName.split(' ~ ');
    if (parts.length >= 5) {
        parts[3] = results.risk.level;
    }
    else {
        parts[2] = results.risk.level;
    }
    const newBaseName = parts.join(' ~ ');
    const newPath = path.join(dir, `${newBaseName}${ext}`);

    if (oldPath !== newPath) {
        const newUri = vscode.Uri.file(newPath);
        await vscode.workspace.fs.rename(uri, newUri, { overwrite: true });
        return newUri;
    }
    return undefined;
}

type SeverityMatrixKey = 'Low-Low' | 'Low-Medium' | 'Low-High' | 'Medium-Low' | 'Medium-Medium' | 'Medium-High' | 'High-Low' | 'High-Medium' | 'High-High';

function calculateRisk(data: any): any {
    const threatAgentFactors = [
        parseInt(data.skillLevel),
        parseInt(data.motive),
        parseInt(data.opportunity),
        parseInt(data.size)
    ];
    const vulnerabilityFactors = [
        parseInt(data.easeOfDiscovery),
        parseInt(data.easeOfExploit),
        parseInt(data.awareness),
        parseInt(data.intrusionDetection)
    ];

    const likelihood = (calculateMean(threatAgentFactors) + calculateMean(vulnerabilityFactors)) / 2;
    const likelihoodLevel = getLevel(likelihood);

    const technicalImpactFactors = [
        parseInt(data.lossOfConfidentiality),
        parseInt(data.lossOfIntegrity),
        parseInt(data.lossOfAvailability),
        parseInt(data.lossOfAccountability)
    ];
    const businessImpactFactors = [
        parseInt(data.financialDamage),
        parseInt(data.reputationDamage),
        parseInt(data.nonCompliance),
        parseInt(data.privacyViolation)
    ];

    const technicalImpact = calculateMean(technicalImpactFactors);
    const businessImpact = calculateMean(businessImpactFactors);

    let overallImpact;
    if (data.type === 'both') {
        overallImpact = calculateMean([technicalImpact,businessImpact]);
    } else if (data.type === 'technical') {
        overallImpact = technicalImpact;
    } else {
        overallImpact = businessImpact;
    }
    const impactLevel = getLevel(overallImpact);

    const riskScore = (likelihood + overallImpact) / 2;
    const riskLevel = getRiskLevel(likelihoodLevel, impactLevel);

    return {
        likelihood: {
            threatAgentFactors: calculateMean(threatAgentFactors),
            vulnerabilityFactors: calculateMean(vulnerabilityFactors),
            overallLikelihood: likelihood,
            level: likelihoodLevel
        },
        impact: {
            technicalImpact: technicalImpact,
            businessImpact: businessImpact,
            overallImpact: overallImpact,
            level: impactLevel
        },
        risk: {
            score: riskScore,
            level: riskLevel
        }
    };
}

function calculateMean(values: number[]): number {
    const sum = values.reduce((a, b) => a + b, 0);
    return sum / values.length;
}

function getLevel(value: number): string {
    return value < 3 ? 'Low' : value < 6 ? 'Medium' : 'High';
}

function getRiskLevel(likelihoodLevel: string, impactLevel: string): string {
    const severityMatrix: Record<SeverityMatrixKey, string> = {
        'Low-Low': 'Note',
        'Low-Medium': 'Low',
        'Low-High': 'Medium',
        'Medium-Low': 'Low',
        'Medium-Medium': 'Medium',
        'Medium-High': 'High',
        'High-Low': 'Medium',
        'High-Medium': 'High',
        'High-High': 'Critical'
    };

    const key = `${likelihoodLevel}-${impactLevel}` as SeverityMatrixKey;
    return severityMatrix[key];
}

function loadPromptContent(filename: string): string {
    const filePath = path.join(__dirname, 'prompts/prod/', filename);
    console.log(`Loading prompt from: ${filePath}`); // Debug log to check file path
    if (!fs.existsSync(filePath)) {
        console.error(`File not found: ${filePath}`);
        return '';
    }
    return fs.readFileSync(filePath, 'utf-8');
}

function showStatusMessage(message: string): vscode.Disposable {
    const statusBarMessage = vscode.window.setStatusBarMessage(message);
    return statusBarMessage;
}

// call chat

async function callChatGPT(openai: OpenAI, prompt: string, sys_prompt: string): Promise<string | null> {
    try {
        const completion = await openai.chat.completions.create({
            //model: "gpt-3.5-turbo-0125",
            model: "gpt-4o",
            messages: [
                { role: "system", content: sys_prompt },
                { role: "user", content: prompt }
            ],
        });
        console.log("Total tokens:", completion.usage?.total_tokens);
        console.log("Prompt tokens:", completion.usage?.prompt_tokens);
        console.log("Completion tokens:", completion.usage?.completion_tokens);

        const messageContent = completion.choices[0]?.message?.content;
        console.log("Message Content:\n", messageContent);

        if (messageContent) {
            return messageContent;
        } else {
            console.error('No message content in the completion response');
            return null;
        }
    } catch (error) {
        console.error(error);
        throw new Error(`Error calling ChatGPT API:`, (error as Error));
    }
}

async function callChatGPTJson(openai: OpenAI, prompt: string, sys_prompt: string): Promise<string | null> {
    try {
        const completion = await openai.chat.completions.create({
            //model: "gpt-3.5-turbo-0125",
            model: "gpt-4o",
            messages: [
                { role: "system", content: sys_prompt },
                { role: "user", content: prompt }
            ],
            response_format: { type: "json_object" },
        });
        console.log("Total tokens:", completion.usage?.total_tokens);
        console.log("Prompt tokens:", completion.usage?.prompt_tokens);
        console.log("Completion tokens:", completion.usage?.completion_tokens);

        const messageContent = completion.choices[0]?.message?.content;
        console.log("Message Content:\n", messageContent);

        if (messageContent) {
            return messageContent;
        } else {
            console.error('No message content in the completion response');
            return null;
        }
    } catch (error) {
        console.error(error);
        throw new Error(`Error calling ChatGPT API:`, (error as Error));
    }
}

export function deactivate() { }